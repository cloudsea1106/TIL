# 📌파이썬 문법

헷갈리는 문법, 놓치기 쉬운 문법 위주

------------------



### ✨실수형

- 소수점 아래의 데이터를 포함하는 수 자료형

- 소수부가 0이거나, 정수부가 0이 소수는 0을 생략하고 작성 가능

  ```python
  a = 5.
  print(a)  # 5.0
  
  a = -.5
  print(a)  # -0.5
  ```

- 오늘날 가장 널리 쓰이는 IEEE754 표준에서는 실수형을 저장하기 위해 4바이트, 또는 8바이트의 고정된 크기의 메모리를 할당

  - 컴퓨터 시스템이 실수 정보를 표현하는 정확도에 한계를 가짐

  - 0.3 + 0.6 → 0.9와 최대한 가깝지만 미세한 오차 발생

    ```python
    a = 0.3 + 0.6
    print(a)  # 0.8999999999999999
    
    if a == 0.9:
        print(True)
    else:
        print(False)  # False
    ```
  
  - round() 함수를 사용하여 해결
  
    - round(123.456, 2) → 123.456을 소수 셋째 자리에서 반올림
  
      ```python
      a = round(123.456, 2)
      print(a)  # 123.46
      ```
  
      ```python
      a = 0.3 + 0.6
      print(round(a, 4))  # 0.9
      
      if round(a, 4) == 0.9:
          print(True)
      else:
          print(False)  # True
      ```
  
      

### ✨사전 자료형

- 키(key)와 값(value)의 쌍을 데이터로 가지는 자료형

- 순서가 없음 → 인덱싱으로 접근 불가

- 변경 불가능한(Immutable) 자료형을 키로 사용할 수 있음

  - 문자열, 튜플, 정수형, 실수형 등

  - 튜플은 변경이 불가능하기 때문에 리스트와 다르게 키 값으로 사용 가능

- 해시 테이블을 이용하므로 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리 가능



### ✨집합 자료형

- 중복을 허용하지 않음

- 순서가 없음 → 인덱싱으로 접근 불가

- 리스트 혹은 문자열을 이용해서 초기화 가능

  - set() 함수 사용

    ```python
    data = [1, 1, 1, 2, 3, 3, 4]
    print(set(data))  # {1, 2, 3, 4}
    ```

- 중괄호({}) 안에 각 원소를 콤마(,) 를 기준으로 구분하여 삽입함으로써 초기화 가능

  ```python
  data = {1, 1, 1, 2, 3, 3, 4}
  print(data)  # {1, 2, 3, 4}
  ```

- 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리 가능



### ✨집합 자료형의 연산

- 합집합: 집합 A에 속하거나 B에 속하는 원소로 이루어진 집합 (A ⋃ B)
- 교집합: 집합 A에도 속하고 B에도 속하는 원소로 이루어진 집합 (A ⋂ B)
- 차집합: 집합 A의 원소 중에서 B에 속하지 않는 원소들로 이루어진 집합 (A − B)

```python
a = set([1, 2, 3, 4, 5])
b = set([3, 4, 5, 6, 7])

# 합집합
print(a | b)  # {1, 2, 3, 4, 5, 6, 7}

# 교집합
print(a & b)  # {3, 4, 5}

# 차집합
print(a - b)  # {1, 2}
```

```python
data = set([1, 2, 3])
print(data)  # {1, 2, 3}

# 새로운 원소 추가
data.add(4)
print(data)  # {1, 2, 3, 4}

# 새로운 원소 여러 개 추가
data.update([5, 6])
print(data)  # {1, 2, 3, 4, 5, 6}

# 특정한 값을 갖는 원소 삭제
data.remove(3)
print(data)  # {1, 2, 4, 5, 6}
```



### ✨논리 연산자

- 논리 값 (True/False) 사이의 연산을 수행할 때 사용

| 논리 연산자 | 설명                                          |
| ----------- | --------------------------------------------- |
| X and Y     | X와 Y가 모두 참(True)일 때 참(True)이다.      |
| X or Y      | X와 Y중에 하나만 참(True)이어도 참(True)이다. |
| not X       | X가 거짓(False)일 때 참(True)이다.            |

- 단축평가: 결과가 확실한 경우 두 번째 값은 확인하지 않고 첫 번째 값 반환

  - and 연산에서 첫 번째 값이 False인 경우 무조건 False → 첫 번째 값 반환
  - or 연산에서 첫 번째 값이 True인 경우 무조건 True → 첫 번째 값 반환

  ```python
  a = 5 and 4
  print(a)  # 4
  
  b = 5 or 3
  print(b)  # 5
  
  c = 0 and 5
  print(c)  # 0
  
  d = 5 or 0
  print(d)  # 5
  
  e = 0 or 3
  print(e)  # 3
  ```



### ✨연산자 우선 순위

- ()
- Slicing
- Indexing
- **
- 단항 연산자(+, -): 부호
- 산술 연산자(*, /, %)
- 산술 연산자(+, -)
- 비교 연산자, in, is
- not
- and
- or



### ✨함수

- 파라미터 지정하기

  - 파라미터의 변수 직접 지정 가능
  - 매개변수의 순서가 달라도 가능

  ```python
  def add(a, b):
      return a + b
  
  print(add(b = 1, a = 2))  # 3
  ```

- global 키워드

  - global 키워드로 변수를 지정하면 함수 바깥에 선언된 변수를 바로 참조함

  ```python
  a = 0
  
  def func():
      global a
      a += 1
  
  func()
  print(a)  # 1
  ```

  - 단순히 값을 참조하는 경우에는 global 키워드를 사용하지 않고도 접근 가능 (값 변경 또는 할당 x)
  - 리스트는 global 키워드 없이 바로 전역변수 참조 가능
    - 함수 내부에 같은 이름의 변수가 존재한다면 함수 내부의 변수를 우선적으로 참조

  ```python
  a = 0
  
  def func():
      print(a)
      print(a + 1)
  
  func()
  # 0
  # 1
  ```

  ```python
  lst = [1, 2, 3]
  
  def func():
      lst.append(4)
  
  func()
  print(lst)  # [1, 2, 3, 4]
  ```

  ```python
  lst = [1, 2, 3]
  
  def func():
      lst = [1, 2]
      lst.append(4)
      print(lst)
  
  func()  # [1, 2, 4]
  print(lst)  # [1, 2, 3]
  ```

  